# Foodika Backend Architecture & Database Design

## 1. System Architecture Overview

**Status:** Principal Architect Approved
**Tech Stack:** PostgreSQL 16, Redis, Node.js/Go (Microservices), Kafka/RabbitMQ

### Layers
1.  **Edge/Gateway:** Nginx + API Gateway (Rate limiting, SSL, Request ID tagging).
2.  **Auth Layer:** Centralized Identity Provider (IdP) handling JWT issuance, Device Certs, and RBAC.
3.  **App Layer:** Modular Monolith or Microservices (split by domain below).
4.  **Data Layer:** 
    *   **Primary:** PostgreSQL (Multi-tenant, partitioned by high-volume tables).
    *   **Cache:** Redis (Session storage, Hot inventory, Real-time dashboards).
    *   **Event Bus:** Kafka/Redis Streams (Asynchronous processing).

---

## 2. Tenancy & Authentication Schema

**Principle:** Strict Logical Isolation. Every query **MUST** filter by `tenant_id`.

### Tables

```sql
-- Root Tenant (The Brand/Company)
CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(50) UNIQUE NOT NULL, -- for subdomains (e.g. burgerking.foodika.app)
    subscription_plan VARCHAR(50), -- 'ENTERPRISE', 'GROWTH'
    config JSONB, -- Global settings (currency, timezone)
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Physical Locations
CREATE TABLE branches (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id),
    name VARCHAR(255) NOT NULL,
    type VARCHAR(50), -- 'STORE', 'WAREHOUSE', 'GHOST_KITCHEN'
    timezone VARCHAR(50),
    is_active BOOLEAN DEFAULT TRUE
);

-- Access Control
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID REFERENCES tenants(id), -- Null for SuperAdmin
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255),
    role VARCHAR(50), -- 'ORG_ADMIN', 'BRANCH_MANAGER'
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- POS Device Identity (Machine Auth)
CREATE TABLE pos_devices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id),
    branch_id UUID NOT NULL REFERENCES branches(id),
    device_fingerprint VARCHAR(255),
    name VARCHAR(100), -- 'Bar iPad 1'
    status VARCHAR(50), -- 'AUTHORIZED', 'BLOCKED'
    last_heartbeat TIMESTAMPTZ
);
```

---

## 3. POS & Orders Domain (The Core)

**Strategy:** Offline-first. IDs are generated on the client (UUID).

```sql
CREATE TABLE orders (
    id UUID PRIMARY KEY, -- Generated by Frontend
    tenant_id UUID NOT NULL REFERENCES tenants(id),
    branch_id UUID NOT NULL REFERENCES branches(id),
    device_id UUID REFERENCES pos_devices(id),
    
    order_number_seq BIGINT, -- Daily sequence number (101, 102...)
    type VARCHAR(50), -- 'DINE_IN', 'DELIVERY', 'TAKEAWAY'
    status VARCHAR(50), -- 'OPEN', 'FIRED', 'READY', 'COMPLETED', 'VOIDED'
    
    table_id UUID, -- Nullable for takeaway
    customer_id UUID,
    waiter_id UUID,
    
    subtotal DECIMAL(12,3),
    tax_total DECIMAL(12,3),
    discount_total DECIMAL(12,3),
    final_total DECIMAL(12,3),
    
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ,
    
    -- Sync Metadata
    client_created_at TIMESTAMPTZ, -- When it happened on device
    version INT DEFAULT 1 -- Optimistic Locking
);

CREATE TABLE order_items (
    id UUID PRIMARY KEY,
    tenant_id UUID NOT NULL,
    order_id UUID NOT NULL REFERENCES orders(id),
    menu_item_id UUID NOT NULL, 
    
    quantity INT NOT NULL,
    unit_price DECIMAL(12,3),
    total_price DECIMAL(12,3),
    
    modifiers JSONB, -- Array of selected modifiers snapshot
    notes TEXT,
    
    status VARCHAR(50), -- 'PENDING', 'COOKING', 'SERVED'
    fired_at TIMESTAMPTZ -- When sent to KDS
);

CREATE TABLE payments (
    id UUID PRIMARY KEY,
    tenant_id UUID NOT NULL,
    branch_id UUID NOT NULL,
    order_id UUID REFERENCES orders(id),
    
    amount DECIMAL(12,3),
    method VARCHAR(50), -- 'CASH', 'CARD', 'KNET', 'LOYALTY'
    reference_code VARCHAR(100), -- Transaction ID from Terminal
    status VARCHAR(50) -- 'SUCCESS', 'FAILED', 'REFUNDED'
);
```

---

## 4. Inventory & Recipe Domain

**Logic:** Weighted Average Cost (WAC) & First-In-First-Out (FIFO).

```sql
CREATE TABLE inventory_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    name VARCHAR(255),
    sku VARCHAR(100),
    unit VARCHAR(20), -- 'kg', 'ltr', 'pcs'
    storage_type VARCHAR(50), -- 'DRY', 'COLD', 'FROZEN'
    
    min_level DECIMAL(10,3),
    par_level DECIMAL(10,3),
    
    current_avg_cost DECIMAL(12,3) -- Recalculated on every Receiving
);

CREATE TABLE inventory_locations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    branch_id UUID NOT NULL,
    name VARCHAR(100) -- 'Main Kitchen', 'Bar Store', 'Warehouse A'
);

CREATE TABLE stock_levels (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    location_id UUID REFERENCES inventory_locations(id),
    inventory_item_id UUID REFERENCES inventory_items(id),
    
    quantity_on_hand DECIMAL(12,3) DEFAULT 0,
    last_counted_at TIMESTAMPTZ,
    
    UNIQUE(location_id, inventory_item_id)
);

-- THE LEDGER (Audit Trail for every gram)
CREATE TABLE stock_movements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    branch_id UUID NOT NULL,
    
    inventory_item_id UUID NOT NULL,
    location_id UUID NOT NULL,
    
    type VARCHAR(50), -- 'SALE_DEDUCTION', 'RECEIVING', 'WASTE', 'TRANSFER_IN', 'TRANSFER_OUT'
    quantity_delta DECIMAL(12,3), -- negative for usage, positive for receiving
    cost_at_time DECIMAL(12,3),
    
    reference_id UUID, -- OrderID, PO ID, or WasteLog ID
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- RECIPES (The connection between POS and Inventory)
CREATE TABLE recipes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    menu_item_id UUID, -- Link to sales item
    
    batch_yield DECIMAL(10,3), -- How much this recipe produces
    version INT DEFAULT 1,
    is_active BOOLEAN
);

CREATE TABLE recipe_ingredients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    recipe_id UUID REFERENCES recipes(id),
    inventory_item_id UUID, -- The raw material
    
    quantity DECIMAL(10,3), -- Amount used
    unit VARCHAR(20),
    yield_loss_pct DECIMAL(5,2) -- e.g. 10% loss peeling potatoes
);
```

---

## 5. Event-Driven Architecture

We use the **Transactional Outbox Pattern**. When an Order is saved, an event is inserted into `outbox_events` in the SAME transaction. A background worker polls this table and pushes to Kafka/Redis.

### Event Schema
```sql
CREATE TABLE outbox_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID,
    aggregate_type VARCHAR(50), -- 'ORDER', 'INVENTORY', 'CUSTOMER'
    aggregate_id UUID,
    event_type VARCHAR(100), -- See list below
    payload JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    status VARCHAR(20) DEFAULT 'PENDING' -- 'PUBLISHED', 'FAILED'
);
```

### Key Domain Events

1.  **`ORDER_CREATED`**
    *   **Trigger:** POS finalized payment.
    *   **Consumers:** 
        *   `KDS_SERVICE`: Display ticket.
        *   `INVENTORY_SERVICE`: Deduct ingredients based on recipe.
        *   `LOYALTY_SERVICE`: Add points to customer.
        *   `ANALYTICS_SERVICE`: Update real-time dashboard.

2.  **`STOCK_LEVEL_LOW`**
    *   **Trigger:** Inventory Service after deduction.
    *   **Consumers:**
        *   `PURCHASING_SERVICE`: Auto-draft Purchase Order?
        *   `NOTIFICATION_SERVICE`: Alert Manager.

3.  **`SHIFT_ENDED`**
    *   **Trigger:** HR/Staff Service.
    *   **Consumers:**
        *   `ACCOUNTING_SERVICE`: Calculate labor cost for the day.

---

## 6. Offline Sync & Conflict Resolution

**Scenario:** Internet cuts out. 50 orders are punched. Internet returns.

**Protocol:**
1.  **Client-Side Queue:** POS stores `orders` in IndexedDB/SQLite with `sync_status: 'PENDING'`.
2.  **Batch Upload:** On connection, POS sends batch of Orders.
3.  **Idempotency:** API checks `orders.id`. If exists, ignore (or update if version is higher).
4.  **Inventory Lag:** Stock is deducted when sync happens. Timestamp of deduction = `created_at` (actual sale time), not sync time.

**Sync API Endpoint:**
`POST /api/v1/sync/orders`
**Payload:**
```json
{
  "device_id": "uuid",
  "batch_id": "uuid",
  "orders": [ ...order_objects ]
}
```

---

## 7. AI & Menu Engineering Schema

```sql
CREATE TABLE menu_performance_snapshots (
    id UUID PRIMARY KEY,
    tenant_id UUID,
    branch_id UUID,
    date DATE,
    
    menu_item_id UUID,
    quantity_sold INT,
    revenue_generated DECIMAL(12,3),
    cost_incurred DECIMAL(12,3),
    
    profit_margin DECIMAL(12,3),
    popularity_index DECIMAL(5,2), -- Calculated vs category avg
    matrix_quadrant VARCHAR(20) -- 'STAR', 'DOG', 'PUZZLE', 'PLOWHORSE'
);

CREATE TABLE ai_recommendations (
    id UUID PRIMARY KEY,
    tenant_id UUID,
    module VARCHAR(50), -- 'COST_CONTROL', 'STAFFING'
    
    trigger_event VARCHAR(100), -- 'MARGIN_DROP_BELOW_20'
    insight_text TEXT,
    suggested_action TEXT,
    projected_impact TEXT,
    
    status VARCHAR(20), -- 'NEW', 'APPLIED', 'DISMISSED'
    feedback_score INT, -- Did this help?
    created_at TIMESTAMPTZ
);
```

---

## 8. Indexing Strategy

1.  **Multi-tenant Filters:**
    *   `CREATE INDEX idx_orders_tenant_branch ON orders(tenant_id, branch_id);`
    *   *Rationale:* Almost every query filters by tenant and branch.

2.  **Time-Series Lookups:**
    *   `CREATE INDEX idx_orders_created_at ON orders(created_at DESC);`
    *   *Rationale:* Reporting usually queries "Last 30 days".

3.  **Inventory Lookups:**
    *   `CREATE INDEX idx_stock_item_location ON stock_levels(inventory_item_id, location_id);`

4.  **JSONB Indexing:**
    *   `CREATE INDEX idx_order_modifiers ON order_items USING GIN (modifiers);`
    *   *Rationale:* To analyze "How many people ordered 'Extra Cheese'?".

---

## 9. API Structure (RESTful)

*   `GET /v1/brands/:brand_id/menu` (Public/Cached)
*   `POST /v1/orders` (Idempotent order placement)
*   `GET /v1/inventory/levels?location={id}` (Real-time stock)
*   `POST /v1/inventory/adjust` (Stock count/waste)
*   `GET /v1/reports/pnl?start={date}&end={date}` (Aggregated accounting)
*   `POST /v1/ai/analyze` (Trigger manual AI sweep)

## 10. Next Implementation Steps

1.  Provision PostgreSQL cluster with `pg_partman` for partitioning `stock_movements` and `orders` by date.
2.  Set up Redis for caching Menu Structures (high read, low write).
3.  Implement the `AuthService` to issue JWTs containing `tenant_id` and `permissions`.
